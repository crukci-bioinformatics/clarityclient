<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.9.2 from src/site/apt/caching.apt at 2020-08-14

 | Rendered using Apache Maven Default Skin
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.9.2" />
    <title>CRUK-CI Genologics API Client &#x2013; </title>
    <link rel="stylesheet" href="./css/maven-base.css" />
    <link rel="stylesheet" href="./css/maven-theme.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
  </head>
  <body class="composite">
    <div id="banner">
<div id="bannerLeft">CRUK-CI Genologics API Client
</div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
      <div class="xleft">
        <span id="publishDate">Last Published: 2020-08-14</span>
          &#xA0;| <span id="projectVersion">Version: 2.27.1</span>
      </div>
      <div class="xright">      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
       <h5>User Guide</h5>
    <ul>
     <li class="none"><a href="index.html" title="Introduction">Introduction</a></li>
     <li class="none"><a href="installing.html" title="Installation">Installation</a></li>
     <li class="expanded"><a href="usageoverview.html" title="Usage">Usage</a>
      <ul>
       <li class="none"><a href="spring.html" title="Spring Configuration">Spring Configuration</a></li>
       <li class="none"><a href="usage.html" title="Basic Usage">Basic Usage</a></li>
       <li class="none"><strong>Caching</strong></li>
       <li class="none"><a href="serverside.html" title="Server Deployment">Server Deployment</a></li>
      </ul></li>
     <li class="none"><a href="issues.html" title="Known Issues">Known Issues</a></li>
     <li class="none"><a href="references.html" title="Reference Documentation">Reference Documentation</a></li>
    </ul>
       <h5>Project Documentation</h5>
    <ul>
     <li class="collapsed"><a href="project-info.html" title="Project Information">Project Information</a></li>
     <li class="collapsed"><a href="project-reports.html" title="Project Reports">Project Reports</a></li>
    </ul>
      <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
      </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
<section>
<h2><a name="Caching"></a>Caching</h2>
<p>Using the in-memory cache with the client can <b>massively</b> increase the speed a script can run. It accumulates a number of entities from REST API calls so subsequent calls to retrieve these same entities need not pass through to the API. This also has the effect to simplifying user code, as the script can make the calls through the <code><a href="./apidocs/org/cruk/genologics/api/GenologicsAPI.html">GenologicsAPI</a></code> interface without worrying about whether it already has some or all of the objects requested.</p>
<p>Like any client side caching, there are risks that an entity will be updated from elsewhere while the client holds an earlier copy of the object. This hasn't presented us much of a problem in EPP scripts (where this client is used a lot) as these run from beginning to end and then stop, so the lifetime of the cache is simply the duration of the script.</p>
<p>If used in a server environment, the cache can still be beneficial but it may need to be tweaked so objects don't live as long in the cache. We've found that most operations rarely hit the same objects from two different people (though this is a risk) and the performance gain much outweighs the risk of out of date information. The cache can be tuned or disabled as required by the application.</p><section>
<h3><a name="Enabling_the_cache"></a>Enabling the cache</h3>
<p>The cache is essentially an aspect around the main <code>GenologicsAPI</code> implementation. It is configured with Spring and can be enabled for an application by adding a file to Spring's application context path:</p>
<div class="source">
<pre>/org/cruk/genologics/api/genologics-cache-context.xml</pre></div>
<p>This configuration does require the general <code>/org/cruk/genologics/api/genologics-client-context.xml</code> configuration to be in Spring's application context path as it depends on beans defined there.</p>
<p><code>genologics-cache-context.xml</code> is provided in the client's JAR file.</p></section><section>
<h3><a name="Tuning_the_cache"></a>Tuning the cache</h3>
<p>The cache is controlled by the file:</p>
<div class="source">
<pre>/org/cruk/genologics/api/ehcache.xml</pre></div>
<p>This file is also provided in the client's JAR file. It provides caches for different entities that can be individually tuned for each class in the API. Any class that does not have a specific cache defined goes into the catch-all cache <i>com.genologics.ri.LimsEntity</i>.</p>
<p>If you do need to change the cache configuration, make a new <code>org/cruk/genologics/api/ehcache.xml</code> that appears in a folder or JAR before the client's JAR file in the class path.</p></section><section>
<h3><a name="Bulk_fetch.2C_create_and_update_operations"></a>Bulk fetch, create and update operations</h3>
<p>Real world use has found that the bulk operations for fetching, creating and updating objects from the API has a &quot;sweet spot&quot; for the number of objects in an operation. This is a number that minimises the request time per object. For example, if one tries fetching 10,000 artifacts in one call to the API's &quot;<code>.../artifacts/batch/retrieve</code>&quot; end point it will take longer than making 20 calls for 500 artifacts (500 per call is the optimum number given by Genologics, though testing has shown this can vary between installations).</p>
<p>As of release 2.22, the client library will batch bulk operations with large numbers of objects into one or more calls to the relevant API end point transparently to the user. So we can request our 10,000 artifacts in one call to the client and let that fetch them in the most efficient manner.</p>
<p>The number of objects to retrieve or send in each batch can be tuned with the <code>setBulkOperationBatchSize</code> method on the client. The default is the recommended 500 per call to the API.</p></section><section>
<h3><a name="Artifacts_and_their_state_parameter"></a>Artifacts and their state parameter</h3>
<p>The <code>Artifact</code> class provides some complication to the cache by always having a <i>state</i> parameter attached to its URIs. This means a given artifact can be returned in different states depending on the state in the URI.</p>
<p>The cache can be put in one of three modes for dealing with <code>Artifact</code> objects:</p>
<ol style="list-style-type: decimal">
<li><code>EXACT</code>: The version of the artifact requested by the state parameter must match the version in the cache exactly. If it is older or newer than the cached version, the requested version is fetched and replaces that already in the cache.</li>
<li><code>LATEST</code>: If the version of the artifact requested by the state parameter is newer than the version in the cache, the requested version is fetched and replaces the version in the cache. If it is the same version or older, the newer version in the cache is returned.</li>
<li><code>ANY</code>: The cached version of the artifact is returned regardless of the version requested by the state parameter.</li></ol>
<p>If an artifact is requested without an explicit state in the URI, the artifact in the cache is returned regardless of its version or the mode of cache operation.</p>
<p>The default mode is <code>LATEST</code>, which is the way the cache behaved in releases of the client before 2.22. Modes can be set in the Spring configuration (<code>genologics-cache-context.xml</code>) or programmatically on the <code>GenologicsAPICache</code> bean using the <code>setStatefulBehaviour</code> method.</p></section><section>
<h3><a name="Overriding_the_cache_behaviour_for_a_single_fetch"></a>Overriding the cache behaviour for a single fetch</h3>
<p>In actual use, the only time the state parameter is important for an artifact is when one is looking for its QC flag value. No other fields have a history that is preserved by the state: they are always their current database value. Most of the time the cache behaviour is irrelevant, and the <code>LATEST</code> or <code>ANY</code> cache behaviours are most suitable for the performance gain they provide. This is not true when using the post process URI of the input/output maps to obtain the QC flags.</p>
<p>Releases 4.24.8 and 2.26.1 introduced the method <code><a href="./apidocs/org/cruk/genologics/api/GenologicsAPI.html">overrideStateful</a></code> to the API. This allows a single call to be made through the API that will fetch the artifact at either the exact version given in the URI or the latest available state.</p>
<p>When <code>overrideStateful</code> is set to <code>EXACT</code>, the client will call through to the Clarity API unless we already have exactly this version of the artifact in the cache. As the call returns the cache follows its normal rules for whether this version of the artifact is cached.</p>
<p>When <code>overrideStateful</code> is set to <code>LATEST</code>, the client will remove the <i>state</i> parameter from the artifact's URI before always calling through to the Clarity API. Again, as the call returns the cache follows its normal rules for whether this version of the artifact is cached. If the client is again instructed to fetch one of the artifact with this same override, the call will go through to the Clarity API again.</p>
<p>The stateful override behaviour is only relevant to artifacts and is in place for exactly one call to the API after the <code>overrideStateful</code> call. It will always be cleared after the next call to the API, regardless of whether it actually has an effect after that call (e.g. calling <code>overrideStateful</code> and then <code>getServer</code> will cause the override to be cleared), so one should put the call to <code>overrideStateful</code> immediately before the call to <code>retrieve</code>, <code>load</code>, <code>loadAll</code> or <code>reload</code>. This behaviour is local to the calling thread, so will not affect calls from other threads.</p></section></section>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
        Copyright &#169;      2013&#x2013;2020<a href="https://www.cruk.cam.ac.uk/">Cancer Research UK Cambridge Institute</a>.
.      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
